# ðŸ“Š Database Schema Documentation

## Database: `face_auth_db`

### Table: `users`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INT | PRIMARY KEY, AUTO_INCREMENT | Unique user identifier |
| `user_identifier` | VARCHAR(255) | UNIQUE, NOT NULL | User-provided ID (e.g., "USER_001") |
| `face_encoding` | TEXT | NOT NULL | 128-dimensional face vector as JSON string |
| `created_at` | TIMESTAMP | DEFAULT CURRENT_TIMESTAMP | Registration timestamp |

### Indexes
- **Primary Key**: `id`
- **Unique Index**: `user_identifier`
- **Index**: `idx_user_identifier` for faster lookups

## Face Encoding Format

The `face_encoding` column stores a JSON array of 128 floating-point numbers:

```json
[
  -0.123456789,
  0.987654321,
  0.456789012,
  ...
  -0.234567890
]
```

This represents the unique mathematical "fingerprint" of a person's face.

## Sample Data

```sql
-- Example entry (face_encoding truncated for display)
INSERT INTO users (user_identifier, face_encoding) VALUES 
(
  'USER_001',
  '[-0.123, 0.456, 0.789, ..., -0.321]'
);
```

## Storage Considerations

- Each face encoding is approximately **1-2 KB** when stored as JSON
- For 1000 users: ~1-2 MB of face data
- No images are stored (only mathematical vectors)
- Encodings cannot be reverse-engineered to recreate the face

## Queries

### Register New User
```sql
INSERT INTO users (user_identifier, face_encoding)
VALUES (?, ?);
```

### Retrieve All Users for Verification
```sql
SELECT user_identifier, face_encoding FROM users;
```

### Check if User Exists
```sql
SELECT id FROM users WHERE user_identifier = ?;
```

### Get User Count
```sql
SELECT COUNT(*) FROM users;
```

### Delete User
```sql
DELETE FROM users WHERE user_identifier = ?;
```

### Get Recent Registrations
```sql
SELECT user_identifier, created_at 
FROM users 
ORDER BY created_at DESC 
LIMIT 10;
```

## Performance Optimization

For large-scale deployments:

1. **Add indexes on frequently queried fields**
2. **Consider partitioning** for millions of users
3. **Cache encodings** in Redis for faster verification
4. **Use connection pooling** for database connections
5. **Implement batch processing** for verification operations

## Backup Strategy

```sql
-- Backup database
mysqldump -u root -p face_auth_db > backup.sql

-- Restore database
mysql -u root -p face_auth_db < backup.sql
```

## Security Best Practices

1. **Never expose face_encoding data** in public APIs
2. **Use prepared statements** (already implemented in app.py)
3. **Hash user_identifiers** if they contain sensitive info
4. **Encrypt database backups**
5. **Set proper MySQL user permissions**

```sql
-- Create dedicated user with limited permissions
CREATE USER 'face_auth_user'@'localhost' IDENTIFIED BY 'secure_password';
GRANT SELECT, INSERT, DELETE ON face_auth_db.users TO 'face_auth_user'@'localhost';
FLUSH PRIVILEGES;
```

## Monitoring

```sql
-- Check table size
SELECT 
    table_name AS 'Table',
    ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)'
FROM information_schema.TABLES
WHERE table_schema = 'face_auth_db'
    AND table_name = 'users';

-- Check record count
SELECT COUNT(*) as total_users FROM users;

-- Check recent activity
SELECT 
    DATE(created_at) as date,
    COUNT(*) as registrations
FROM users
GROUP BY DATE(created_at)
ORDER BY date DESC
LIMIT 7;
```

---

**Note**: Face encodings are generated by the `face_recognition` library using dlib's ResNet model, trained on millions of faces for high accuracy.
